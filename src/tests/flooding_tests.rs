#[cfg(test)]
#[allow(unused_imports, unreachable_code, unused_variables)]
pub mod flooding_tests {
    use std::collections::HashMap;
    use crossbeam_channel::{unbounded, Receiver, Sender};
    use rand::{Rng};
    use rustafarian_shared::messages::commander_messages::{SimControllerCommand, SimControllerResponseWrapper};
    use wg_2024::network::{NodeId, SourceRoutingHeader};
    use wg_2024::packet::{FloodRequest, FloodResponse, Packet, PacketType};
    use wg_2024::packet::NodeType::{Client, Drone, Server};
    use crate::chat_server::ChatServer;

    /// Init a test ChatServer with 2 drones connected to it
    ///
    /// # Return
    /// Returns the init server
    fn init_test_network() -> (
        ChatServer,
        Receiver<Packet>,
        Receiver<Packet>,
        Receiver<SimControllerResponseWrapper>
    ) {

        // NEIGHBOURS CHANNELS
        let node_2: (Sender<Packet>, Receiver<Packet>) = unbounded();
        let node_3: (Sender<Packet>, Receiver<Packet>) = unbounded();

        let mut neighbours_map = HashMap::new();
        neighbours_map.insert(2 as NodeId, node_2.0);
        neighbours_map.insert(3 as NodeId, node_3.0);

        // SIM CONTROLLER CHANNELS
        // SIM CONTROLLER CHANNELS
        let sim_controller_resp: (Sender<SimControllerResponseWrapper>, Receiver<SimControllerResponseWrapper>) = unbounded();
        let sim_controller_recv: Receiver<SimControllerCommand> = unbounded().1;

        // SERVER CHANNELS
        let server_channel: (Sender<Packet>, Receiver<Packet>) = unbounded();

        let server: ChatServer = ChatServer::new(
            1,
            sim_controller_recv,
            sim_controller_resp.0,
            server_channel.1,
            neighbours_map,
            true
        );

        (server, node_2.1, node_3.1, sim_controller_resp.1)
    }

    #[test]
    fn should_handle_flood_request() {

        let mut rng = rand::thread_rng();
        let (mut server, recv2, recv3, _) = init_test_network();
        let session_id: u64 = rng.gen();
        let flood_id: u64 = rng.gen();

        // Create a mock flood request, generated by a non-existing client and received through
        // Drone 3
        let flood_request = FloodRequest {
            flood_id,
            initiator_id: 8,
            path_trace: vec![(8, Client), (7, Drone), (3, Drone)]
        };

        // Create a new packet with the flood request
        let flood_request_packet = Packet::new_flood_request(
            SourceRoutingHeader::empty_route(),
            session_id,
            flood_request.clone()
        );

        server.handle_received_packet(Ok(flood_request_packet));

        // Receive the flood request from the server
        let recv_2 = recv2.recv().unwrap();

        // Assert they are the same request, with same session id
        assert_eq!(session_id, recv_2.session_id);

        // Just check the packet is a flood request and check the content
        assert!(matches!(recv_2.pack_type, PacketType::FloodRequest(_)));
        match recv_2.pack_type {
            PacketType::FloodRequest(recv_flood_request) => {
                assert_eq!(flood_request.flood_id, recv_flood_request.flood_id);
                assert_eq!(flood_request.initiator_id, recv_flood_request.initiator_id);
                assert!(recv_flood_request.path_trace.contains(&(1, Server)))
            }
            _ => { !panic!("Unexpected packet type"); }
        }

        // Check that no message is sent on the recv3 channel
        assert!(recv3.try_recv().is_err());
    }

    #[test]
    fn should_handle_flood_response() {

        let mut rng = rand::thread_rng();
        let (mut server, recv2, recv3, _) = init_test_network();
        let session_id: u64 = rng.gen();

        // Since the server initializes the current flood_id to zero, this is also set to zero
        // If no other flood request is created this should not rise a problem in the tests
        // A little sketchy, but it works
        let flood_id: u64 = 0;
        let flood_request = FloodRequest {
            flood_id,
            initiator_id: 8,
            path_trace: vec![(1, Server), (3, Drone), (7, Drone), (8, Client)],
        };

        // Compute the route, used to send the response back through the network
        let mut route: Vec<u8> = flood_request.path_trace
            .iter()
            .map(|node| node.0)
            .collect();
        route.reverse();

        let flood_response = Packet::new_flood_response(
            SourceRoutingHeader::new(route, 3),
            session_id,
            FloodResponse {
                flood_id,
                path_trace: flood_request.path_trace
            }
        );

        server.handle_received_packet(Ok(flood_response));

        // Check that the server correctly updated the flood status
        assert!(!server.is_flooding());

        // Assert the topology is correctly updated
        // NODES
        assert!(server.topology().nodes().contains(&3));
        assert!(server.topology().nodes().contains(&7));
        assert!(server.topology().nodes().contains(&8));

        // EDGES
        assert!(server.topology().edges().get(&3).unwrap().contains(&7));
        assert!(server.topology().edges().get(&7).unwrap().contains(&3));
        assert!(server.topology().edges().get(&7).unwrap().contains(&8));
        assert!(server.topology().edges().get(&8).unwrap().contains(&7));
    }

    #[test]
    fn should_handle_flood_response_not_initiator() {

        let mut rng = rand::thread_rng();
        let (
            mut server,
            recv2,
            recv3,
            sc_receiver
        ) = init_test_network();
        let session_id: u64 = rng.gen();
        let flood_id: u64 = rng.gen();

        // Server 9 is the initiator, the response is passing through the current server, received
        // from Node 3 and should be sent through Node 2
        let flood_request = FloodRequest {
            flood_id,
            initiator_id: 8,
            path_trace: vec![(9, Server), (2, Drone), (1, Server), (3, Drone), (7, Drone), (8, Client)],
        };

        // Compute the route, used to send the response back through the network
        let mut route: Vec<u8> = flood_request.path_trace
            .iter()
            .map(|node| node.0)
            .collect();
        route.reverse();

        let flood_response = Packet::new_flood_response(
            SourceRoutingHeader::new(route, 3),
            session_id,
            FloodResponse {
                flood_id,
                path_trace: flood_request.path_trace
            }
        );

        server.handle_received_packet(Ok(flood_response));

        // Check Sim Controller is notified
        assert!(sc_receiver.try_recv().is_ok());

        // Check the response is forwarded to the right node
        let recv_2 = recv2.recv().unwrap();
        // Assert they are the same request, with same session id
        assert_eq!(session_id, recv_2.session_id);
        // Check that the hop_index has been updated
        assert_eq!(4, recv_2.routing_header.hop_index);
    }

}