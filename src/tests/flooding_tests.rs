#[cfg(test)]
pub mod flooding_tests {
    use std::collections::HashMap;
    use crossbeam_channel::{unbounded, Receiver, Sender};
    use rand::{random, Rng};
    use rustafarian_shared::messages::commander_messages::{SimControllerCommand, SimControllerResponseWrapper};
    use wg_2024::network::{NodeId, SourceRoutingHeader};
    use wg_2024::packet::{FloodRequest, Packet, PacketType};
    use wg_2024::packet::NodeType::{Client, Drone, Server};
    use crate::chat_server::ChatServer;

    /// Init a test ChatServer with 2 drones connected to it
    ///
    /// # Return
    /// Returns the init server
    fn init_test_network() -> (
        ChatServer,
        Receiver<Packet>,
        Receiver<Packet>
    ) {

        // NEIGHBOURS CHANNELS
        let node_2: (Sender<Packet>, Receiver<Packet>) = unbounded();
        let node_3: (Sender<Packet>, Receiver<Packet>) = unbounded();

        let mut neighbours_map = HashMap::new();
        neighbours_map.insert(2 as NodeId, node_2.0);
        neighbours_map.insert(3 as NodeId, node_3.0);

        // SIM CONTROLLER CHANNELS
        let sim_controller_send: Sender<SimControllerResponseWrapper> = unbounded().0;
        let sim_controller_recv: Receiver<SimControllerCommand> = unbounded().1;

        // SERVER CHANNELS
        let server_channel: (Sender<Packet>, Receiver<Packet>) = unbounded();

        let server: ChatServer = ChatServer::new(
            1,
            sim_controller_recv,
            sim_controller_send,
            server_channel.1,
            neighbours_map,
            true
        );

        (server, node_2.1, node_3.1)
    }

    #[test]
    fn should_handle_flood_request() {

        let mut rng = rand::thread_rng();
        let (mut server, recv2, recv3) = init_test_network();
        let session_id: u64 = rng.gen();

        // Create a mock flood request, generated by a non-existing client and received through
        // Drone 3
        let flood_request = FloodRequest {
            flood_id: 1234,
            initiator_id: 8,
            path_trace: vec![(3, Drone), (7, Drone), (8, Client)],
        };

        // Create a new packet with the flood request
        let flood_request_packet = Packet::new_flood_request(
            SourceRoutingHeader::empty_route(),
            session_id,
            flood_request.clone()
        );

        server.handle_received_packet(Ok(flood_request_packet));

        // Receive the flood request from the server
        let recv_2 = recv2.recv().unwrap();
        let recv_3 = recv3.recv().unwrap();

        // Assert they are the same request, with same session id
        assert_eq!(session_id, recv_2.session_id);
        assert_eq!(session_id, recv_3.session_id);

        // Just check the packet is a flood request and check the content
        assert!(matches!(recv_2.pack_type, PacketType::FloodRequest(_)));
        match recv_2.pack_type {
            PacketType::FloodRequest(recv_flood_request) => {
                assert_eq!(flood_request.flood_id, recv_flood_request.flood_id);
                assert_eq!(flood_request.initiator_id, recv_flood_request.initiator_id);
                assert!(recv_flood_request.path_trace.contains(&(1, Server)))
            }
            _ => { !panic!("Unexpected packet type"); }
        }
    }
}